# 预测市场聚合交易终端 - 智能合约开发文档

| 文档版本 | 日期 | 作者 | 状态 |
| :--- | :--- | :--- | :--- |
| v1.0 | 2026-01-31 | 成员A | 草稿 |

---

## 1. 概述

本文档为预测市场聚合交易终端项目的智能合约开发指南，专注于**接口设计**，使用 **Foundry** 框架开发，集成 **OpenZeppelin** 合约库。

### 1.1 合约清单

| 合约 | 标准 | 职责 |
| :--- | :--- | :--- |
| `USDC.sol` | ERC20 | 测试用USDC代币，支持任意铸造 |
| `TradingHub.sol` | - | 订单管理合约：记录用户订单、结算 |

### 1.3 角色定义

| 角色 | 地址来源 | 权限 |
| :--- | :--- | :--- |
| **Owner** | 部署者 | 下单 (`placeOrder`)、结算 (`settle`) |
| **User** | 任意用户 | 授权USDC、查询订单 |

### 1.2 技术栈

- **语言**: Solidity ^0.8.20
- **框架**: Foundry (forge, cast, anvil)
- **依赖**: OpenZeppelin Contracts v5.x
- **网络**: 0G Testnet (Chain ID: 16600, RPC: `https://evmrpc-testnet.0g.ai`)

---

## 2. 项目结构

```
contracts/
├── foundry.toml              # Foundry 配置
├── remappings.txt            # 依赖映射
├── .env                      # 环境变量
├── src/
│   ├── USDC.sol
│   ├── TradingHub.sol
│   └── interfaces/
│       ├── IUSDC.sol
│       └── ITradingHub.sol
├── test/
│   ├── USDC.t.sol
│   ├── TradingHub.t.sol
│   └── Integration.t.sol
├── script/
│   └── Deploy.s.sol
└── lib/
    └── openzeppelin-contracts/
```

---

## 3. 环境配置

### 3.1 foundry.toml

```toml
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc = "0.8.20"
optimizer = true
optimizer_runs = 200

[rpc_endpoints]
og_testnet = "${OG_RPC_URL}"
localhost = "http://127.0.0.1:8545"

[fmt]
line_length = 120
tab_width = 4
```

### 3.2 remappings.txt

```
@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/
```

### 3.3 环境变量 (.env)

```bash
# 0G 测试网
OG_RPC_URL=https://evmrpc-testnet.0g.ai

# 部署钱包
DEPLOYER_PRIVATE_KEY=

# Oracle 钱包 (用于 resolveMarket)
ORACLE_PRIVATE_KEY=

# 合约地址 (部署后填入)
_USDC_ADDRESS=
TRADING_HUB_ADDRESS=
```

---

## 4. USDC 合约接口

### 4.1 基本信息

| 属性 | 值 |
| :--- | :--- |
| 名称 | USDC |
| 符号 | dUSDC |
| 精度 | 6 (与真实USDC一致) |
| 标准 | ERC20 |

### 4.2 接口定义

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IUSDC is IERC20 {
    // ============ 常量 ============
    
    /// @notice 单次铸造上限
    function MAX_MINT_AMOUNT() external view returns (uint256);
    
    /// @notice 铸造冷却时间
    function MINT_COOLDOWN() external view returns (uint256);

    // ============ 状态查询 ============
    
    /// @notice 查询地址上次铸造时间
    function lastMintTime(address account) external view returns (uint256);

    // ============ 核心功能 ============
    
    /// @notice 铸造测试代币 (有数量和冷却限制)
    /// @param to 接收地址
    /// @param amount 铸造数量 (6位小数)
    function mint(address to, uint256 amount) external;

    /// @notice 无限制铸造 (仅用于测试脚本)
    /// @param to 接收地址
    /// @param amount 铸造数量
    function mintUnlimited(address to, uint256 amount) external;

    // ============ 错误定义 ============
    
    error MintAmountExceeded(uint256 requested, uint256 maximum);
    error MintCooldownNotPassed(uint256 remainingTime);
}
```

### 4.3 函数说明

| 函数 | 权限 | 说明 |
| :--- | :--- | :--- |
| `mint(to, amount)` | 任何人 | 铸造测试代币，单次上限10,000 dUSDC，冷却1小时 |
| `mintUnlimited(to, amount)` | 任何人 | 无限制铸造，仅用于测试脚本 |
| `transfer/approve/...` | 标准ERC20 | 继承自OpenZeppelin ERC20 |

---

## 5. TradingHub 合约接口

### 5.1 核心数据结构

```solidity
/// @notice 订单结构
struct Order {
    uint256 orderId;      // 订单ID (自增)
    address user;         // 用户地址
    bytes32 marketId;     // 项目/市场ID
    uint8 outcome;        // 选择: 0=NO, 1=YES
    uint256 amount;       // 购买数量 (USDC, 6位小数)
    uint256 timestamp;    // 下单时间戳
    bool settled;         // 是否已结算
}

/// @notice 订单状态枚举
enum OrderStatus {
    Pending,     // 0: 待结算
    Won,         // 1: 获胜 (已结算)
    Lost         // 2: 失败 (已结算)
}
```

### 5.2 常量定义

```solidity
uint8 constant OUTCOME_NO = 0;
uint8 constant OUTCOME_YES = 1;
```

### 5.3 接口定义

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface ITradingHub {
    // ============ 数据结构 ============
    
    struct Order {
        uint256 orderId;
        address user;
        bytes32 marketId;
        uint8 outcome;
        uint256 amount;
        uint256 timestamp;
        bool settled;
    }

    // ============ 事件 ============
    
    /// @notice 订单创建事件
    event OrderPlaced(
        uint256 indexed orderId,
        address indexed user,
        bytes32 indexed marketId,
        uint8 outcome,
        uint256 amount
    );
    
    /// @notice 订单结算事件
    event OrderSettled(
        uint256 indexed orderId,
        address indexed user,
        bytes32 indexed marketId,
        bool won,
        uint256 payout
    );

    /// @notice 批量结算事件
    event MarketSettled(
        bytes32 indexed marketId,
        uint8 winningOutcome,
        uint256 totalOrders
    );

    // ============ 错误定义 ============
    
    error InvalidAmount();
    error InvalidOutcome();
    error OrderNotFound();
    error OrderAlreadySettled();
    error MarketNotSettled();
    error InsufficientContractBalance();

    // ============ 下单 (仅Owner) ============
    
    /// @notice 为用户创建订单
    /// @param user 用户地址
    /// @param marketId 项目/市场ID
    /// @param outcome 选择 (0=NO, 1=YES)
    /// @param amount 购买数量 (USDC, 6位小数)
    /// @return orderId 创建的订单ID
    /// @dev 仅 Owner 可调用
    function placeOrder(
        address user,
        bytes32 marketId,
        uint8 outcome,
        uint256 amount
    ) external returns (uint256 orderId);

    // ============ 结算 (仅Owner) ============
    
    /// @notice 结算单个订单
    /// @param orderId 订单ID
    /// @param won 是否获胜
    /// @dev 仅 Owner 可调用
    /// @dev 获胜则支付 amount * 2，失败则不支付
    function settleOrder(uint256 orderId, bool won) external;

    /// @notice 批量结算市场的所有订单
    /// @param marketId 市场ID
    /// @param winningOutcome 获胜结果 (0=NO, 1=YES)
    /// @dev 仅 Owner 可调用
    function settleMarket(bytes32 marketId, uint8 winningOutcome) external;

    // ============ 视图函数 ============
    
    /// @notice 获取订单详情
    /// @param orderId 订单ID
    /// @return order 订单结构体
    function getOrder(uint256 orderId) external view returns (Order memory);

    /// @notice 获取用户的所有订单ID列表
    /// @param user 用户地址
    /// @return orderIds 订单ID数组
    function getUserOrders(address user) external view returns (uint256[] memory);

    /// @notice 获取市场的所有订单ID列表
    /// @param marketId 市场ID
    /// @return orderIds 订单ID数组
    function getMarketOrders(bytes32 marketId) external view returns (uint256[] memory);

    /// @notice 获取用户在指定市场的订单
    /// @param user 用户地址
    /// @param marketId 市场ID
    /// @return orderIds 订单ID数组
    function getUserMarketOrders(address user, bytes32 marketId) external view returns (uint256[] memory);

    /// @notice 获取下一个订单ID
    function nextOrderId() external view returns (uint256);

    /// @notice 获取 USDC 合约地址
    function usdc() external view returns (address);

    /// @notice 获取订单总数
    function totalOrders() external view returns (uint256);
}
```

### 5.4 函数权限与说明

| 函数 | 权限 | 说明 |
| :--- | :--- | :--- |
| `placeOrder` | **Owner** | 为用户创建订单，从用户转入USDC |
| `settleOrder` | **Owner** | 结算单个订单 |
| `settleMarket` | **Owner** | 批量结算市场所有订单 |
| `getOrder` | 任何人 | 查询订单详情 |
| `getUserOrders` | 任何人 | 查询用户的所有订单 |
| `getMarketOrders` | 任何人 | 查询市场的所有订单 |
| `getUserMarketOrders` | 任何人 | 查询用户在指定市场的订单 |

### 5.5 业务逻辑说明

**下单流程 (`placeOrder`)**:
1. Owner 调用，传入用户地址、市场ID、YES/NO选择、购买数量
2. 合约从用户地址转入 `amount` 的 USDC（需用户预先 approve）
3. 创建订单记录，返回订单ID

**结算流程 (`settleOrder` / `settleMarket`)**:
1. Owner 调用，传入订单ID和是否获胜
2. 如果获胜：支付 `amount * 2` 给用户（本金 + 等额收益）
3. 如果失败：不支付（本金已在下单时转入合约）
4. 标记订单为已结算

---

## 6. 交易流程

### 6.1 下单流程

```
用户在前端选择市场和 YES/NO:
  1. 用户 approve USDC 给 TradingHub 合约 (首次/额度不足时)
  2. 后端 (Owner) 调用 TradingHub.placeOrder(user, marketId, outcome, amount)
  3. TradingHub 从用户 transferFrom USDC
  4. TradingHub 创建订单记录
```

### 6.2 结算流程

```
市场结果确定后:
  1. 后端 (Owner) 调用 settleMarket(marketId, winningOutcome)
  2. 遍历该市场所有订单:
     - 如果订单 outcome == winningOutcome: 支付 amount * 2 给用户
     - 如果订单 outcome != winningOutcome: 不支付
  3. 标记所有订单为已结算
```

### 6.3 资金流转示例

```
用户下单 (YES, 100 USDC):
  └─ 用户转入: 100 USDC → 合约

市场结算 (YES 获胜):
  └─ 合约支付: 200 USDC → 用户 (本金 + 收益)

市场结算 (NO 获胜):
  └─ 用户获得: 0 USDC (本金归合约)
```

---

## 7. 部署流程

### 7.1 部署顺序

1. 部署 `USDC`
2. 部署 `TradingHub(USDC地址)`
3. 记录合约地址到 `.env`

### 7.2 部署命令

```bash
# 加载环境变量
source .env

# 本地测试 (Anvil)
anvil &
forge script script/Deploy.s.sol --rpc-url http://127.0.0.1:8545 --broadcast

# 部署到 0G 测试网
forge script script/Deploy.s.sol --rpc-url $OG_RPC_URL --broadcast -vvvv
```

### 7.3 验证合约

```bash
forge verify-contract <ADDRESS> src/USDC.sol:USDC \
    --chain-id 16600 \
    --verifier-url https://chainscan-newton.0g.ai/api

forge verify-contract <ADDRESS> src/TradingHub.sol:TradingHub \
    --chain-id 16600 \
    --constructor-args $(cast abi-encode "constructor(address)" <USDC_ADDRESS>) \
    --verifier-url https://chainscan-newton.0g.ai/api
```

---

## 8. 前端集成要点

### 8.1 主要交互流程

| 操作 | 调用方 | 合约调用 |
| :--- | :--- | :--- |
| 领取测试币 | 用户 | `USDC.mint(user, amount)` |
| 授权 | 用户 | `USDC.approve(TradingHub, amount)` |
| 下单 | **后端(Owner)** | `TradingHub.placeOrder(user, marketId, outcome, amount)` |
| 结算 | **后端(Owner)** | `TradingHub.settleMarket(marketId, winningOutcome)` |
| 查询订单 | 任何人 | `TradingHub.getOrder(orderId)` |
| 查询用户订单 | 任何人 | `TradingHub.getUserOrders(user)` |

### 8.2 事件监听

```javascript
// 监听订单创建
hub.on("OrderPlaced", (orderId, user, marketId, outcome, amount) => {
    console.log(`订单 ${orderId}: 用户 ${user} 下单 ${outcome === 1 ? 'YES' : 'NO'} ${amount}`);
});

// 监听订单结算
hub.on("OrderSettled", (orderId, user, marketId, won, payout) => {
    console.log(`订单 ${orderId} 结算: ${won ? '获胜' : '失败'}, 支付 ${payout}`);
});

// 监听市场结算
hub.on("MarketSettled", (marketId, winningOutcome, totalOrders) => {
    console.log(`市场 ${marketId} 已结算: ${winningOutcome === 1 ? 'YES' : 'NO'} 获胜, 共 ${totalOrders} 笔订单`);
});
```

---

## 9. 安全设计

### 9.1 使用的安全措施

| 措施 | 来源 | 用途 |
| :--- | :--- | :--- |
| `ReentrancyGuard` | OpenZeppelin | 防重入攻击 |
| `SafeERC20` | OpenZeppelin | 安全代币转账 |
| `Ownable` | OpenZeppelin | Oracle权限控制 |
| Custom Errors | Solidity 0.8+ | 节省gas，清晰错误 |

### 9.2 已知限制 (Demo版本)

| 限制 | 说明 | 生产建议 |
| :--- | :--- | :--- |
| 中心化控制 | Owner 控制下单和结算 | 考虑去中心化方案 |
| 固定赔率 | 1:1 赔率 (获胜得双倍) | 支持动态赔率 |
| 无手续费 | 不收取交易费 | 添加协议费用机制 |
| 无时间限制 | 市场无截止时间 | 添加到期自动关闭 |

---

## 10. 常用命令速查

```bash
# 编译
forge build

# 测试
forge test
forge test -vvvv              # 详细输出
forge test --match-test xxx   # 指定测试

# 覆盖率
forge coverage

# Gas报告
forge test --gas-report

# 格式化
forge fmt

# 本地节点
anvil

# 合约交互
cast call <CONTRACT> "getUserBalance(address)" <USER> --rpc-url $OG_RPC_URL
cast send <CONTRACT> "deposit(uint256)" 1000000 --private-key $KEY --rpc-url $OG_RPC_URL
```

---

## 11. 附录：MarketId 生成规则

MarketId 由后端服务根据 Polymarket 的市场数据生成：

```javascript
// 后端生成 marketId
const marketId = ethers.keccak256(
    ethers.toUtf8Bytes(polymarketConditionId)
);
```

前端和合约使用相同的 `bytes32 marketId` 进行交互。
