# 预测市场聚合交易终端 - 智能合约开发文档

| 文档版本 | 日期 | 作者 | 状态 |
| :--- | :--- | :--- | :--- |
| v1.0 | 2026-01-31 | 成员A | 草稿 |

---

## 1. 概述

本文档为预测市场聚合交易终端项目的智能合约开发指南，专注于**接口设计**，使用 **Foundry** 框架开发，集成 **OpenZeppelin** 合约库。

### 1.1 合约清单

| 合约 | 标准 | 职责 |
| :--- | :--- | :--- |
| `DemoUSDC.sol` | ERC20 | 测试用USDC代币，支持任意铸造 |
| `TradingHub.sol` | ERC1155 | 核心交易合约：资金管理、订单撮合、市场结算、结果代币 |

### 1.2 技术栈

- **语言**: Solidity ^0.8.20
- **框架**: Foundry (forge, cast, anvil)
- **依赖**: OpenZeppelin Contracts v5.x
- **网络**: 0G Testnet (Chain ID: 16600, RPC: `https://evmrpc-testnet.0g.ai`)

---

## 2. 项目结构

```
contracts/
├── foundry.toml              # Foundry 配置
├── remappings.txt            # 依赖映射
├── .env                      # 环境变量
├── src/
│   ├── DemoUSDC.sol
│   ├── TradingHub.sol
│   └── interfaces/
│       ├── IDemoUSDC.sol
│       └── ITradingHub.sol
├── test/
│   ├── DemoUSDC.t.sol
│   ├── TradingHub.t.sol
│   └── Integration.t.sol
├── script/
│   └── Deploy.s.sol
└── lib/
    └── openzeppelin-contracts/
```

---

## 3. 环境配置

### 3.1 foundry.toml

```toml
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc = "0.8.20"
optimizer = true
optimizer_runs = 200

[rpc_endpoints]
og_testnet = "${OG_RPC_URL}"
localhost = "http://127.0.0.1:8545"

[fmt]
line_length = 120
tab_width = 4
```

### 3.2 remappings.txt

```
@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/
```

### 3.3 环境变量 (.env)

```bash
# 0G 测试网
OG_RPC_URL=https://evmrpc-testnet.0g.ai

# 部署钱包
DEPLOYER_PRIVATE_KEY=

# Oracle 钱包 (用于 resolveMarket)
ORACLE_PRIVATE_KEY=

# 合约地址 (部署后填入)
DEMO_USDC_ADDRESS=
TRADING_HUB_ADDRESS=
```

---

## 4. DemoUSDC 合约接口

### 4.1 基本信息

| 属性 | 值 |
| :--- | :--- |
| 名称 | DemoUSDC |
| 符号 | dUSDC |
| 精度 | 6 (与真实USDC一致) |
| 标准 | ERC20 |

### 4.2 接口定义

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IDemoUSDC is IERC20 {
    // ============ 常量 ============
    
    /// @notice 单次铸造上限
    function MAX_MINT_AMOUNT() external view returns (uint256);
    
    /// @notice 铸造冷却时间
    function MINT_COOLDOWN() external view returns (uint256);

    // ============ 状态查询 ============
    
    /// @notice 查询地址上次铸造时间
    function lastMintTime(address account) external view returns (uint256);

    // ============ 核心功能 ============
    
    /// @notice 铸造测试代币 (有数量和冷却限制)
    /// @param to 接收地址
    /// @param amount 铸造数量 (6位小数)
    function mint(address to, uint256 amount) external;

    /// @notice 无限制铸造 (仅用于测试脚本)
    /// @param to 接收地址
    /// @param amount 铸造数量
    function mintUnlimited(address to, uint256 amount) external;

    // ============ 错误定义 ============
    
    error MintAmountExceeded(uint256 requested, uint256 maximum);
    error MintCooldownNotPassed(uint256 remainingTime);
}
```

### 4.3 函数说明

| 函数 | 权限 | 说明 |
| :--- | :--- | :--- |
| `mint(to, amount)` | 任何人 | 铸造测试代币，单次上限10,000 dUSDC，冷却1小时 |
| `mintUnlimited(to, amount)` | 任何人 | 无限制铸造，仅用于测试脚本 |
| `transfer/approve/...` | 标准ERC20 | 继承自OpenZeppelin ERC20 |

---

## 5. TradingHub 合约接口

### 5.1 核心数据结构

```solidity
/// @notice 订单结构
struct Order {
    uint256 id;           // 订单ID (自增)
    address owner;        // 订单所有者
    bytes32 marketId;     // 市场ID (来自Polymarket)
    uint8 outcome;        // 结果选择: 0=NO, 1=YES
    uint8 side;           // 买卖方向: 0=BUY, 1=SELL
    uint256 price;        // 价格 (1-99, 代表概率百分比)
    uint256 amount;       // 剩余未成交数量
    uint256 timestamp;    // 创建时间戳
    bool isActive;        // 是否活跃
}

/// @notice 市场状态枚举
enum MarketStatus {
    Active,      // 0: 活跃，可交易
    Resolved,    // 1: 已解析
    Cancelled    // 2: 已取消
}

/// @notice 市场结构
struct Market {
    MarketStatus status;      // 市场状态
    uint8 winningOutcome;     // 获胜结果 (0=NO, 1=YES)
    uint256 resolvedAt;       // 解析时间戳
}
```

### 5.2 常量定义

```solidity
uint8 constant OUTCOME_NO = 0;
uint8 constant OUTCOME_YES = 1;
uint8 constant SIDE_BUY = 0;
uint8 constant SIDE_SELL = 1;

uint256 constant MIN_PRICE = 1;      // 最低价格 1%
uint256 constant MAX_PRICE = 99;     // 最高价格 99%
uint256 constant PRICE_PRECISION = 100;
```

### 5.3 接口定义

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface ITradingHub {
    // ============ 数据结构 ============
    
    struct Order {
        uint256 id;
        address owner;
        bytes32 marketId;
        uint8 outcome;
        uint8 side;
        uint256 price;
        uint256 amount;
        uint256 timestamp;
        bool isActive;
    }

    // ============ 事件 ============
    
    /// @notice 用户充值事件
    event Deposit(address indexed user, uint256 amount);
    
    /// @notice 用户提现事件
    event Withdraw(address indexed user, uint256 amount);
    
    /// @notice 订单创建事件
    event OrderPlaced(
        uint256 indexed orderId,
        address indexed owner,
        bytes32 indexed marketId,
        uint8 outcome,
        uint8 side,
        uint256 price,
        uint256 amount
    );
    
    /// @notice 订单取消事件
    event OrderCancelled(uint256 indexed orderId, address indexed owner);
    
    /// @notice 订单撮合事件
    event OrderMatched(
        bytes32 indexed marketId,
        uint256 buyOrderId,
        uint256 sellOrderId,
        uint256 price,
        uint256 amount,
        address indexed buyer,
        address indexed seller
    );
    
    /// @notice 市场解析事件
    event MarketResolved(bytes32 indexed marketId, uint8 winningOutcome, uint256 timestamp);
    
    /// @notice 代币赎回事件
    event Redemption(
        address indexed user,
        bytes32 indexed marketId,
        uint256 tokenAmount,
        uint256 usdcAmount
    );

    // ============ 错误定义 ============
    
    error InvalidAmount();
    error InsufficientBalance();
    error InvalidPrice();
    error InvalidOutcome();
    error InvalidSide();
    error MarketNotActive();
    error MarketAlreadyResolved();
    error MarketNotResolved();
    error OrderNotFound();
    error NotOrderOwner();
    error OrderNotActive();
    error NoWinningTokens();

    // ============ 资金管理 ============
    
    /// @notice 充值 dUSDC 到交易合约
    /// @param amount 充值数量
    /// @dev 需要先 approve 给本合约
    function deposit(uint256 amount) external;

    /// @notice 从交易合约提现 dUSDC
    /// @param amount 提现数量
    function withdraw(uint256 amount) external;

    /// @notice 获取用户在合约中的 dUSDC 余额
    /// @param user 用户地址
    /// @return 余额数量
    function getUserBalance(address user) external view returns (uint256);

    // ============ 订单管理 ============
    
    /// @notice 创建限价订单
    /// @param marketId 市场ID (bytes32, 来自Polymarket)
    /// @param outcome 结果选择 (0=NO, 1=YES)
    /// @param side 买卖方向 (0=BUY, 1=SELL)
    /// @param price 价格 (1-99, 代表概率百分比)
    /// @param amount 数量 (6位小数)
    /// @return orderId 创建的订单ID
    /// @dev 买单锁定 price * amount / 100 的USDC
    /// @dev 卖单需持有代币或锁定 (100-price) * amount / 100 的USDC
    function placeOrder(
        bytes32 marketId,
        uint8 outcome,
        uint8 side,
        uint256 price,
        uint256 amount
    ) external returns (uint256 orderId);

    /// @notice 取消订单
    /// @param orderId 订单ID
    /// @dev 退还锁定的资金
    function cancelOrder(uint256 orderId) external;

    /// @notice 获取订单详情
    /// @param orderId 订单ID
    /// @return order 订单结构体
    function getOrder(uint256 orderId) external view returns (Order memory);

    /// @notice 获取用户的所有订单ID列表
    /// @param user 用户地址
    /// @return orderIds 订单ID数组
    function getUserOrders(address user) external view returns (uint256[] memory);

    /// @notice 获取用户的活跃订单列表
    /// @param user 用户地址
    /// @return orders 活跃订单数组
    function getUserActiveOrders(address user) external view returns (Order[] memory);

    // ============ 市场结算 ============
    
    /// @notice 解析市场结果
    /// @param marketId 市场ID
    /// @param winningOutcome 获胜结果 (0=NO, 1=YES)
    /// @dev 仅 Owner (Oracle) 可调用
    function resolveMarket(bytes32 marketId, uint8 winningOutcome) external;

    /// @notice 赎回获胜代币
    /// @param marketId 市场ID
    /// @dev 每个获胜代币兑换 1 dUSDC
    function redeem(bytes32 marketId) external;

    // ============ 视图函数 ============
    
    /// @notice 计算结果代币的 ERC1155 tokenId
    /// @param marketId 市场ID
    /// @param outcome 结果 (0=NO, 1=YES)
    /// @return tokenId ERC1155代币ID
    /// @dev tokenId = keccak256(marketId, outcome) & type(uint128).max
    function getTokenId(bytes32 marketId, uint8 outcome) external pure returns (uint256);

    /// @notice 获取市场状态
    /// @param marketId 市场ID
    /// @return status 市场状态 (0=Active, 1=Resolved, 2=Cancelled)
    /// @return winningOutcome 获胜结果 (仅在Resolved时有效)
    function getMarketStatus(bytes32 marketId) external view returns (uint8 status, uint8 winningOutcome);

    /// @notice 获取订单簿指定价格的深度
    /// @param marketId 市场ID
    /// @param outcome 结果 (0=NO, 1=YES)
    /// @param side 方向 (0=BUY, 1=SELL)
    /// @param price 价格 (1-99)
    /// @return totalAmount 该价格的总挂单量
    function getOrderBookDepth(
        bytes32 marketId,
        uint8 outcome,
        uint8 side,
        uint256 price
    ) external view returns (uint256);

    /// @notice 获取订单簿快照
    /// @param marketId 市场ID
    /// @param outcome 结果 (0=NO, 1=YES)
    /// @return bidPrices 买单价格数组
    /// @return bidAmounts 买单数量数组
    /// @return askPrices 卖单价格数组
    /// @return askAmounts 卖单数量数组
    function getOrderBookSnapshot(
        bytes32 marketId,
        uint8 outcome
    ) external view returns (
        uint256[] memory bidPrices,
        uint256[] memory bidAmounts,
        uint256[] memory askPrices,
        uint256[] memory askAmounts
    );

    /// @notice 获取下一个订单ID
    function nextOrderId() external view returns (uint256);

    /// @notice 获取 dUSDC 合约地址
    function demoUSDC() external view returns (address);
}
```

### 5.4 函数权限与说明

| 函数 | 权限 | 说明 |
| :--- | :--- | :--- |
| `deposit` | 任何人 | 充值dUSDC到合约，需先approve |
| `withdraw` | 任何人 | 提现自己的dUSDC余额 |
| `placeOrder` | 任何人 | 创建限价订单，自动尝试撮合 |
| `cancelOrder` | 订单所有者 | 取消自己的活跃订单 |
| `resolveMarket` | Owner (Oracle) | 报告市场结果 |
| `redeem` | 任何人 | 赎回自己的获胜代币 |
| `getOrder` | 任何人 | 查询订单详情 |
| `getUserBalance` | 任何人 | 查询用户余额 |
| `getOrderBookDepth` | 任何人 | 查询订单簿深度 |
| `getTokenId` | 任何人 | 计算代币ID |
| `getMarketStatus` | 任何人 | 查询市场状态 |

### 5.5 ERC1155 结果代币

TradingHub 继承 ERC1155，用于表示市场结果代币：

| 属性 | 说明 |
| :--- | :--- |
| tokenId 计算 | `uint256(keccak256(marketId, outcome)) & type(uint128).max` |
| YES 代币 | `getTokenId(marketId, 1)` |
| NO 代币 | `getTokenId(marketId, 0)` |
| 赎回价值 | 获胜代币 1:1 兑换 dUSDC |

---

## 6. 交易流程

### 6.1 订单撮合逻辑

```
买单 (BUY):
  - 锁定资金: price * amount / 100
  - 撮合: 寻找价格 <= 买价的卖单
  - 成交: 买方获得结果代币，卖方获得USDC

卖单 (SELL):
  - 如持有代币: 无需锁定资金
  - 如无代币 (做市商模式): 锁定 (100-price) * amount / 100
  - 撮合: 寻找价格 >= 卖价的买单
  - 成交: 卖方获得USDC，买方获得结果代币
```

### 6.2 资金流转

```
下单 (BUY YES @ 60, 100个):
  └─ 锁定: 60 * 100 / 100 = 60 dUSDC

撮合成功 (与 SELL YES @ 55 成交):
  ├─ 买方: 获得 100 个 YES 代币
  └─ 卖方: 获得 55 dUSDC (按成交价)

市场解析 (YES 获胜):
  └─ 买方赎回: 100 YES 代币 → 100 dUSDC
```

---

## 7. 部署流程

### 7.1 部署顺序

1. 部署 `DemoUSDC`
2. 部署 `TradingHub(demoUSDC地址)`
3. 记录合约地址到 `.env`

### 7.2 部署命令

```bash
# 加载环境变量
source .env

# 本地测试 (Anvil)
anvil &
forge script script/Deploy.s.sol --rpc-url http://127.0.0.1:8545 --broadcast

# 部署到 0G 测试网
forge script script/Deploy.s.sol --rpc-url $OG_RPC_URL --broadcast -vvvv
```

### 7.3 验证合约

```bash
forge verify-contract <ADDRESS> src/DemoUSDC.sol:DemoUSDC \
    --chain-id 16600 \
    --verifier-url https://chainscan-newton.0g.ai/api

forge verify-contract <ADDRESS> src/TradingHub.sol:TradingHub \
    --chain-id 16600 \
    --constructor-args $(cast abi-encode "constructor(address)" <USDC_ADDRESS>) \
    --verifier-url https://chainscan-newton.0g.ai/api
```

---

## 8. 前端集成要点

### 8.1 主要交互流程

| 操作 | 合约调用 |
| :--- | :--- |
| 领取测试币 | `DemoUSDC.mint(user, amount)` |
| 授权 | `DemoUSDC.approve(TradingHub, amount)` |
| 充值 | `TradingHub.deposit(amount)` |
| 下单 | `TradingHub.placeOrder(marketId, outcome, side, price, amount)` |
| 取消订单 | `TradingHub.cancelOrder(orderId)` |
| 查询余额 | `TradingHub.getUserBalance(user)` |
| 查询持仓 | `TradingHub.balanceOf(user, tokenId)` (ERC1155) |
| 赎回 | `TradingHub.redeem(marketId)` |
| 提现 | `TradingHub.withdraw(amount)` |

### 8.2 事件监听

```javascript
// 监听订单撮合
hub.on("OrderMatched", (marketId, buyOrderId, sellOrderId, price, amount, buyer, seller) => {
    console.log(`成交: ${amount} @ ${price}%`);
});

// 监听市场解析
hub.on("MarketResolved", (marketId, winningOutcome, timestamp) => {
    console.log(`市场 ${marketId} 已解析: ${winningOutcome === 1 ? 'YES' : 'NO'} 获胜`);
});
```

---

## 9. 安全设计

### 9.1 使用的安全措施

| 措施 | 来源 | 用途 |
| :--- | :--- | :--- |
| `ReentrancyGuard` | OpenZeppelin | 防重入攻击 |
| `SafeERC20` | OpenZeppelin | 安全代币转账 |
| `Ownable` | OpenZeppelin | Oracle权限控制 |
| Custom Errors | Solidity 0.8+ | 节省gas，清晰错误 |

### 9.2 已知限制 (Demo版本)

| 限制 | 说明 | 生产建议 |
| :--- | :--- | :--- |
| 单一Oracle | 仅Owner可报告结果 | 使用Chainlink等去中心化预言机 |
| 无手续费 | 不收取交易费 | 添加协议费用机制 |
| 简化撮合 | 链上全量撮合 | 考虑链下撮合+链上结算 |
| 无时间限制 | 市场无截止时间 | 添加到期自动关闭 |

---

## 10. 常用命令速查

```bash
# 编译
forge build

# 测试
forge test
forge test -vvvv              # 详细输出
forge test --match-test xxx   # 指定测试

# 覆盖率
forge coverage

# Gas报告
forge test --gas-report

# 格式化
forge fmt

# 本地节点
anvil

# 合约交互
cast call <CONTRACT> "getUserBalance(address)" <USER> --rpc-url $OG_RPC_URL
cast send <CONTRACT> "deposit(uint256)" 1000000 --private-key $KEY --rpc-url $OG_RPC_URL
```

---

## 11. 附录：MarketId 生成规则

MarketId 由后端服务根据 Polymarket 的市场数据生成：

```javascript
// 后端生成 marketId
const marketId = ethers.keccak256(
    ethers.toUtf8Bytes(polymarketConditionId)
);
```

前端和合约使用相同的 `bytes32 marketId` 进行交互。
